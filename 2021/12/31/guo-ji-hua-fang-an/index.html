<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><link rel="icon" sizes="any" type="image/svg+xml" href="/imgs/icon.svg"><link rel="stylesheet" href="/css/theme/color.variables.css"><link id="themeStyleVar" rel="stylesheet" href="/css/theme/default.variables.css"><script>const localStorageTheme = localStorage.getItem('theme');
        function loadTheme(){
            let themeLink = document.getElementById('themeStyleVar');
            if(localStorageTheme){
                themeLink.href = themeLink.href.replace(/\/css\/theme.*/,`/css/theme/${localStorageTheme}.variables.css`)
            }
        }
        if(localStorage){
            loadTheme()
            setTimeout(()=>{
                if(document.body){
                    document.body.className = localStorageTheme ? localStorageTheme : 'dark'
                }

            },2)
        }</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/post.css"><title>苏鑫2017</title><meta name="description" content="用于记录感悟，前端技术，编程技巧，各种奇奇怪怪的新的体会"><meta name="viewport" content="width=device-width,initial-scale=1"><script async>console.log(`%c真巧，你打开了devtool`,"color:#b58900")
        console.log(`%c真巧，你看了我的文章`,"color:#859900")
        console.log('%c简单介绍，道法自然，做人要顺其自然，不要有太多欲望',"color:#268bd2")
        console.log('%c不要目的性太强,这就是我的主题想强调的',"color:#dc322f")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RFGTVED02M"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-RFGTVED02M")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?ce46d6101f33ba04b74fbe8bbe509590";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const moduleMap = new Map();
            var define = (moduleName, module) => { moduleMap.set(moduleName, module) };
            var require = (moduleName) => moduleMap.get(moduleName);</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="苏鑫2017" type="application/atom+xml"></head><body><div class="body"><header class="header"><div class="header-icon-wrapper"><h2><a href="/">苏鑫2017</a></h2></div><div class="header-right"><nav class="header-menu-wrapper"><ul class="header-menu"><li class="header-menu-item"><a class="header-menu-item-link" href="/">首页</a></li><li class="header-menu-item"><a class="header-menu-item-link" href="/categories/weibo">微博</a></li><li class="header-menu-item"><a class="header-menu-item-link" href="/about">关于</a></li><li class="header-menu-item"><div id="switchThemeButton"><img src="/imgs/icon.svg" alt="switchThemeIcon" width="100%" height="100%"></div><style>#switchThemeButton{width:40px;height:26px;margin:0;border:0;background:0 0;outline:0;cursor:pointer;margin-top:6px}</style><script async>const btn = document.getElementById('switchThemeButton');
    let darkTheme = false;
    const themeStyleVarId = "themeStyleVar";
    if(localStorageTheme === 'dark'){
        darkTheme = true
    }else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        // dark mode
        darkTheme = true;
    }
    function loadTheme() {
        let themeLink = document.getElementById(themeStyleVarId);
        if (!themeLink) {
            themeLink = document.createElement('link')
            themeLink.rel = "stylesheet"
            themeLink.id = "themeStyleVar"
        }
        darkTheme = !darkTheme;
        themeLink.href = themeLink.href.replace(/\/css\/theme.*/,`/css/theme/${darkTheme ? 'dark' : 'light'}.variables.css`)
        document.head.appendChild(themeLink)
        document.body.className = darkTheme?'dark':'light'
        localStorage.setItem('theme',darkTheme?'dark':'light');
    }

    btn.onclick = function() {
        loadTheme();
        codeTheme();
    }</script><script>function codeTheme(){
            const localStorageTheme = localStorage.getItem('theme');
            let codeThemeLink = document.getElementById("codeTheme");
            if(!codeThemeLink){
                codeThemeLink = document.createElement('link');
                codeThemeLink.rel = "stylesheet"
                codeThemeLink.id = "codeTheme"
                document.head.appendChild(codeThemeLink)
            }
            if(localStorageTheme){
                codeThemeLink.href = `//cdn.jsdelivr.net/npm/highlightjs@9.16.2/styles/solarized-${localStorageTheme}.css`
            }else{
                codeThemeLink.href = `//cdn.jsdelivr.net/npm/highlightjs@9.16.2/styles/solarized-${darkTheme ? 'dark': 'light'}.css`
            }
        }
        codeTheme()</script></li></ul></nav></div></header><main class="main"><div class="post"><h2>国际化方案</h2><h3 id="前端-i18n-库的选择">前端 i18n 库的选择</h3><p>市面上比较流行的只有两种，两者功能差不太多。</p><p><a target="_blank" rel="noopener" href="https://react.i18next.com/">i18n-next</a></p><ul><li>可支持插件拓展</li><li>不支持编译自动生成 key （但是可以直接用文案当作 key）</li></ul><p><a target="_blank" rel="noopener" href="https://formatjs.io/docs/react-intl/">react-intl</a></p><ul><li>不支持插件拓展，但支持高阶 hoc 的拓展</li><li>支持编译时自动生成 key</li></ul><h3 id="i18n-的本质">i18n 的本质</h3><p>key - value 映射<br>不管哪种方案都是 key - value 的映射，抓住本质他的概念就很好理解。</p><p>如下</p><pre><code class="hljs"><span class="hljs-comment">// 只是切换时候加载不同对象内容。</span>
<span class="hljs-keyword">let</span> languages = &#123;
  <span class="hljs-attr">en</span>: &#123;
    <span class="hljs-string">&quot;common.hello&quot;</span>: <span class="hljs-string">&quot;hello&quot;</span>,
  &#125;,
  <span class="hljs-attr">zh</span>: &#123;
    <span class="hljs-string">&quot;common.hello&quot;</span>: <span class="hljs-string">&quot;你好&quot;</span>,
  &#125;,
&#125;;
</code></pre><h3 id="i18n-需要解决的问题">i18n 需要解决的问题</h3><h4 id="key-的选取">key 的选取</h4><p>如上所述 react-intl 支持自动生成 key，也支持手写 key。<br>i18n-next 貌似只支持手写 key。<br>key 的常见规则如下</p><pre><code class="hljs"><span class="hljs-comment">// 规则一：手写，短语拼接</span>
<span class="hljs-keyword">let</span> languages = &#123;
  <span class="hljs-attr">en</span>: &#123;
    <span class="hljs-comment">// 短语方式写key</span>
    <span class="hljs-string">&quot;common.hello&quot;</span>: <span class="hljs-string">&quot;hello&quot;</span>,
  &#125;,
&#125;;
<span class="hljs-comment">// 规则二： 手写，直接用文案当key</span>
<span class="hljs-keyword">let</span> languages = &#123;
  <span class="hljs-attr">en</span>: &#123;
    <span class="hljs-comment">// 这种可能文案生成的json会很大</span>
    <span class="hljs-string">&quot;hello ,i am fine and you?&quot;</span>: <span class="hljs-string">&quot;hello ,i am fine and you?&quot;</span>,
  &#125;,
&#125;;
<span class="hljs-comment">// 规则三： 自动生成</span>
<span class="hljs-comment">//react intl 支持自动生成</span>
<span class="hljs-comment">// 举例</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-keyword">const</span> intl = <span class="hljs-title function_">useIntl</span>();
  <span class="hljs-keyword">return</span> intl.<span class="hljs-title function_">formatMessage</span>(&#123; <span class="hljs-attr">defaultMessage</span>: <span class="hljs-string">&quot;hello&quot;</span> &#125;);
  <span class="hljs-comment">//                                          ^^^^^^^</span>
  <span class="hljs-comment">// 在编译时候会给你生成</span>
  <span class="hljs-comment">// intl.formatMessage(&#123;id:&#x27;generateKeyRule(&quot;hello&quot;)&#x27;,defaultMessage:&quot;hello&quot;&#125;);</span>
  <span class="hljs-comment">// generateKeyRul 可以自己指定，还有一些额外上下文变量可以使用，比如文件路径。</span>
  <span class="hljs-comment">// 可以生成这种内容sha1</span>
  <span class="hljs-comment">// intl.formatMessage(&#123;id:&#x27;asdjfkasjdfxxx&#x27;,defaultMessage:&quot;hello&quot;&#125;);</span>
&#125;
</code></pre><p>对比下三种规则优缺点</p><table><thead><tr><th></th><th>手写短语</th><th>文案就是 key</th><th>自动生成</th></tr></thead><tbody><tr><td>优点</td><td>无文案依赖，也就是说它只作为页面的一个占位符，你想换文案就可以换文案</td><td>无文案依赖，相比手写更加易于理解</td><td>无文案 key 维护成本,翻译易于复用</td></tr><tr><td>缺点</td><td>累，维护 key 贼累，翻译可能不易复用</td><td>代码显示文案可能与线上显示文案不符</td><td>依赖文案生成 key，依赖文案的变更需要重新生成 key，重新上线,文案冲突频率变高，需要选择一种基准文案（建议项目母语，变更频率最低）</td></tr><tr><td>适用场景</td><td>文案少，变更频繁，可自定义覆盖，c 端，组件库</td><td>没想好</td><td>文案多，变更不频繁，b 端</td></tr></tbody></table><p>ps: 文案冲突</p><pre><code class="hljs"><span class="hljs-comment">// 自动生成key的文案冲突问题</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-keyword">const</span> intl = <span class="hljs-title function_">useIntl</span>();
  <span class="hljs-keyword">return</span> intl.<span class="hljs-title function_">formatMessage</span>(&#123; <span class="hljs-attr">defaultMessage</span>: <span class="hljs-string">&quot;select&quot;</span> &#125;);
  <span class="hljs-comment">//                                          ^^^^^^^</span>
  <span class="hljs-comment">// 对应中文可能是 选择图片，选择视频</span>
  <span class="hljs-comment">// 解决办法，添加描述性语句辅助生成key</span>
  <span class="hljs-comment">// return intl.formatMessage(&#123; defaultMessage: &quot;select&quot;,  description: &#x27;image&#x27;, &#125;);</span>
  <span class="hljs-comment">// zh: 选择图像 key-&gt; select#video (react-intl 拼接规则)</span>

  <span class="hljs-comment">// return intl.formatMessage(&#123; defaultMessage: &quot;select&quot;,  description: &#x27;video&#x27;, &#125;);</span>
  <span class="hljs-comment">// zh: 选择视频 key-&gt; select#video (react-intl 拼接规则)</span>

  <span class="hljs-comment">// return intl.formatMessage(&#123; defaultMessage: &quot;select&quot; &#125;);</span>
  <span class="hljs-comment">// zh: 选择 key-&gt; select</span>
&#125;
</code></pre><h3 id="可能遇见的状况（低频）">可能遇见的状况（低频）</h3><p>货币，数字国际化，i18n 是提供这个 api 的，可放心食用。</p><h3 id="基础库解决的问题">基础库解决的问题</h3><ul><li>文案提取的能力。</li></ul><pre><code class="hljs"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-keyword">const</span> intl = <span class="hljs-title function_">useIntl</span>();
  <span class="hljs-keyword">return</span> intl.<span class="hljs-title function_">formatMessage</span>(&#123; <span class="hljs-attr">defaultMessage</span>: <span class="hljs-string">&quot;hello&quot;</span> &#125;);
  <span class="hljs-comment">// return intl.formatMessage(&#123; id:&quot;id&quot;, defaultMessage: &quot;hello&quot; &#125;);</span>
&#125;

<span class="hljs-comment">// ===&gt; 提取json</span>
<span class="hljs-comment">// 类似这种</span>
<span class="hljs-comment">// &#123;</span>
<span class="hljs-comment">// 	&quot;id || generateKeyRule(text)&quot; : &quot;hello&quot;</span>
<span class="hljs-comment">// &#125;</span>
</code></pre><ul><li>key-value 映射</li></ul><h3 id="基础库未解决的问题">基础库未解决的问题</h3><ul><li>文案管理</li></ul><p>随着业务迭代，文案越来越多，会有废弃文案，新增文案的概念。<br>需要一个平台存储文案，然后前端项目获取文案，可根据从项目中提取的文案与存储文案的地方做对比，然后获取文案。</p><ul><li>文案完整度</li></ul><p>如何确保多国翻译，或者部分国翻译 100%已有翻译，还是需要从项目中获取项目中使用的文案，然后对比语言包。</p><ul><li>翻译流程</li></ul><p>一条文案的产生的源头通常 prd，然后设计复制一份并拓展，然后研发根据设计稿开发，当提测是应提交项目中的文案到，待翻译状态，然后翻译组/产品/机翻，进行翻译，然后前端项目获取这些文案，进行文案完整度上线前检测即可。<br>这个是最难的，要拉起设计、产品、研发的认知才能搞。</p><ul><li><p>翻译文案</p><p>如何保证一条文案在语境下的正确性？</p><ul><li>方案一：<br>文案+设计图<br>实现难度低</li><li>方案二：<br>文案+页面<br>实现难度复杂</li></ul></li><li><p>文案关联页面</p><p>可通过webpack 插件开发处理chunk信息获取</p><p>所以需要一个平台/平台周边生态去做这些事</p></li></ul><h3 id="参考">参考</h3><p>i18n-next 文案平台<br><a target="_blank" rel="noopener" href="https://locize.com/">https://locize.com/</a><br>vscode i18n all in one 插件<br><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=Lokalise.i18n-ally">https://marketplace.visualstudio.com/items?itemName=Lokalise.i18n-ally</a></p><p>阿里的轮子<br><a target="_blank" rel="noopener" href="https://github.com/alibaba/react-intl-universal">https://github.com/alibaba/react-intl-universal</a><br><a target="_blank" rel="noopener" href="https://github.com/alibaba/kiwi">https://github.com/alibaba/kiwi</a></p><script async>let codes = document.getElementsByClassName('hljs');
            Array.from(codes).forEach(code => {
                code.addEventListener('click', function copy(e) {
                    const textContent = e.currentTarget.textContent;
                    e.currentTarget.focus()
                    const node = e.currentTarget;
                    navigator.clipboard.writeText(textContent).then(()=>{
                        alert('复制成功')
                        node.blur()
                    });
                   
                })
            })</script><script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({startOnLoad:!0})</script></div></main><footer><p>Copyright © 2019-2022 suxin2017</p><p class="icp"><span><img src="/imgs/icp.png" width="17px" height="17px" alt="icp"> </span><a href="http://beian.miit.gov.cn" class="icp-link"><span>京ICP备2020041991号</span></a></p><p><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></p></footer></div></body></html>