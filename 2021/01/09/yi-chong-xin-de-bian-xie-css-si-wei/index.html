<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><link rel="icon" sizes="any" type="image/svg+xml" href="/imgs/icon.svg"><link rel="stylesheet" href="/css/theme/color.variables.css"><link id="themeStyleVar" rel="stylesheet" href="/css/theme/default.variables.css"><script>const localStorageTheme = localStorage.getItem('theme');
        function loadTheme(){
            let themeLink = document.getElementById('themeStyleVar');
            if(localStorageTheme){
                themeLink.href = themeLink.href.replace(/\/css\/theme.*/,`/css/theme/${localStorageTheme}.variables.css`)
            }
        }
        if(localStorage){
            loadTheme()
            setTimeout(()=>{
                if(document.body){
                    document.body.className = localStorageTheme ? localStorageTheme : 'dark'
                }

            },2)
        }</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/post.css"><title>苏鑫2017</title><meta name="description" content="用于记录感悟，前端技术，编程技巧，各种奇奇怪怪的新的体会"><meta name="viewport" content="width=device-width,initial-scale=1"><script async>console.log(`%c真巧，你打开了devtool`,"color:#b58900")
        console.log(`%c真巧，你看了我的文章`,"color:#859900")
        console.log('%c简单介绍，道法自然，做人要顺其自然，不要有太多欲望',"color:#268bd2")
        console.log('%c不要目的性太强,这就是我的主题想强调的',"color:#dc322f")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RFGTVED02M"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-RFGTVED02M")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?ce46d6101f33ba04b74fbe8bbe509590";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const moduleMap = new Map();
            var define = (moduleName, module) => { moduleMap.set(moduleName, module) };
            var require = (moduleName) => moduleMap.get(moduleName);</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="苏鑫2017" type="application/atom+xml"></head><body><div class="body"><header class="header"><div class="header-icon-wrapper"><h2><a href="/">苏鑫2017</a></h2></div><div class="header-right"><nav class="header-menu-wrapper"><ul class="header-menu"><li class="header-menu-item"><a class="header-menu-item-link" href="/">首页</a></li><li class="header-menu-item"><a class="header-menu-item-link" href="/categories/weibo">微博</a></li><li class="header-menu-item"><a class="header-menu-item-link" href="/about">关于</a></li><li class="header-menu-item"><div id="switchThemeButton"><img src="/imgs/icon.svg" alt="switchThemeIcon" width="100%" height="100%"></div><style>#switchThemeButton{width:40px;height:26px;margin:0;border:0;background:0 0;outline:0;cursor:pointer;margin-top:6px}</style><script async>const btn = document.getElementById('switchThemeButton');
    let darkTheme = false;
    const themeStyleVarId = "themeStyleVar";
    if(localStorageTheme === 'dark'){
        darkTheme = true
    }else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        // dark mode
        darkTheme = true;
    }
    function loadTheme() {
        let themeLink = document.getElementById(themeStyleVarId);
        if (!themeLink) {
            themeLink = document.createElement('link')
            themeLink.rel = "stylesheet"
            themeLink.id = "themeStyleVar"
        }
        darkTheme = !darkTheme;
        themeLink.href = themeLink.href.replace(/\/css\/theme.*/,`/css/theme/${darkTheme ? 'dark' : 'light'}.variables.css`)
        document.head.appendChild(themeLink)
        document.body.className = darkTheme?'dark':'light'
        localStorage.setItem('theme',darkTheme?'dark':'light');
    }

    btn.onclick = function() {
        loadTheme();
        codeTheme();
    }</script><script>function codeTheme(){
            const localStorageTheme = localStorage.getItem('theme');
            let codeThemeLink = document.getElementById("codeTheme");
            if(!codeThemeLink){
                codeThemeLink = document.createElement('link');
                codeThemeLink.rel = "stylesheet"
                codeThemeLink.id = "codeTheme"
                document.head.appendChild(codeThemeLink)
            }
            if(localStorageTheme){
                codeThemeLink.href = `//cdn.jsdelivr.net/npm/highlightjs@9.16.2/styles/solarized-${localStorageTheme}.css`
            }else{
                codeThemeLink.href = `//cdn.jsdelivr.net/npm/highlightjs@9.16.2/styles/solarized-${darkTheme ? 'dark': 'light'}.css`
            }
        }
        codeTheme()</script></li></ul></nav></div></header><main class="main"><div class="post"><h2>一种新的编写css思维</h2><p>每个前端开发者都经常根据业务的进行写着大量重复的 css 样式，写时一时爽，维护火葬场。</p><p>随着业务的发展，css 代码会变得越来越多越来越难以维护。</p><p>经常会出现 important 强行改变 css 的样式，这样做的唯一好处就是能够符合当前业务需求，但是自己挖的坑，可能是别人哭爹骂娘跪着填上的，而这一切仅仅是因为大量重复的垃圾代码。</p><h2 id="css-魔法数字">css 魔法数字</h2><p>在代码重构中有一点就是减少你代码中的魔法数字。</p><p>我们在写 css 的时候经常会写</p><pre><code class="hljs"><span class="hljs-selector-tag">body</span> &#123;
  <span class="hljs-comment">/** 经常使用#fff的人会知道这是白色，
     ** 那么换个颜色呢 #A855F7 
     ** 这个是紫色 
     **/</span>
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;

  <span class="hljs-comment">/** 又或者这种4px，4px 到底代表什么，我需要全局搜索改变所有的4px吗
     **/</span>
  <span class="hljs-attribute">border</span>-raduis: <span class="hljs-number">4px</span>;
&#125;
</code></pre><p>这样的代码我们一遍又一遍地 <code>style</code> 标签里面书写，增大我们 css 文件的体积。</p><h2 id="css-框架">css 框架</h2><p>前端 css 框架有很多，以比较流行的<strong>Bootstrap</strong>来举例。</p><p>Bootstrap 提供了 布局、组件、工具样式类，他们用来搭建 Bootstrap 风格的网站很好用，但是如果定制化的时候，他们太重了，一切变得不那么灵活。</p><p>当我们要定制一个自己风格的样式的时候需要做大量的样式阅读，以防不小心影响其他组件，极其难以维护。</p><p>这一切来自于 css 代码的副作用（各种 css 权重之间的影响)</p><p>是时候在灵活性和快速使用之间做抉择了。</p><p>如果你喜欢开箱即用，当前一定使用了一个组件库，如果你想从头搭建一套高可用并且容易维护的组件库或者网站，那么应该尝试一下 tailwindcss 了。</p><h3 id="tailwindcss">tailwindcss</h3><blockquote><p>用组合的方式去编辑你的样式代码</p></blockquote><p><strong>tailwindcss</strong> 提供了各种样式的工具类，从布局，间距，大小，文字，颜色每个都提供了工具类。</p><p>有了这些工具类，我们可以尽情地组合样式。</p><h4 id="组件化开发">组件化开发</h4><p>正如前端的发展，每一个前端框架都提供着组件化的开发模式，不提倡组件间继承，而是通过组合的方式去开发维护组件。</p><p>那么 html 的样式也应该如此，换种方式去编写你的代码吧。</p><pre><code class="hljs">// 正常代码
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">
<span class="hljs-selector-class">.card</span> &#123;
    <span class="hljs-attribute">border</span>-radiux: <span class="hljs-number">0.25rem</span>;
    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">#0000</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">#0000</span>, <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">3px</span> <span class="hljs-number">0</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>), <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">2px</span> <span class="hljs-number">0</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.06</span>);
&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre><pre><code class="hljs"><span class="hljs-comment">// tailwindcss</span>
&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">rounded</span> <span class="hljs-symbol">shadow</span>&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;
</code></pre><p>两份代码同样实现了一个这样的卡片，第一种写法如果我要修改圆角我会增加或者减少 rem 的值，但是下面的写法我只需修改一个更加语义化的类名即可。</p><p><img src="/imgs/card.png" alt="字体的查找"></p><p>再也不用想如何定义我的类名了<code>card-title</code> <code>card-head-title</code> <code>card-body-content</code>，只要定义好我的组件名就可以在 react 中,配合 classnames 更是能让外层直接通过类去改变组件样式，拓展性变得更强大，更加灵活。</p><h2 id="总结">总结</h2><p>tailwindcss 是一个强大的 css 工具类库，能够让我们编写更加灵活的，易于复用的样式代码，优化无用样式，减少 css 文件体积，方便拓展。</p><p>当然任何事物都有好的和坏的一面，tailwindcss 不好的点在于，虽然 css 文件体积缩小，但是 html 中存在大量的类名，而且各种缩写需要一定时间熟悉。</p><p>什么时候应该用 tailwindcss 呢？ 如果你厌烦了无时无刻重复编写 css 代码，如果你想要自己的网站或者组件更加灵活，tailwindcss 值得一试。</p><script async>let codes = document.getElementsByClassName('hljs');
            Array.from(codes).forEach(code => {
                code.addEventListener('click', function copy(e) {
                    const textContent = e.currentTarget.textContent;
                    e.currentTarget.focus()
                    const node = e.currentTarget;
                    navigator.clipboard.writeText(textContent).then(()=>{
                        alert('复制成功')
                        node.blur()
                    });
                   
                })
            })</script><script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({startOnLoad:!0})</script></div></main><footer><p>Copyright © 2019-2022 suxin2017</p><p class="icp"><span><img src="/imgs/icp.png" width="17px" height="17px" alt="icp"> </span><a href="http://beian.miit.gov.cn" class="icp-link"><span>京ICP备2020041991号</span></a></p><p><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></p></footer></div></body></html>